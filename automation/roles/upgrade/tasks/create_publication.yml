---
# Blue-green upgrade method: Create publications and slots for logical replication.

# One publication (if pg_publication_count = 1)
- block:
    - name: "Create publication for logical replication (database: {{ dbname | default('postgres') }})"
      ansible.builtin.command: >-
        {{ psql_command }} -d {{ dbname }} -tAXc "
        drop publication if exists {{ publication_name }};
        create publication {{ publication_name }} for all tables;"

    - name: "Create slot for logical replication (database: {{ dbname | default('postgres') }})"
      ansible.builtin.command: >-
        {{ psql_command }} -d {{ dbname }} -tAXc "
        select pg_drop_replication_slot('{{ slot_name }}')
        from pg_replication_slots where slot_name = '{{ slot_name }}';
        select lsn from pg_create_logical_replication_slot('{{ slot_name }}', 'pgoutput');"
      register: pg_slot_lsn

    - name: "Set variable: target_lsn"
      ansible.builtin.set_fact:
        target_lsn: "{{ pg_slot_lsn.stdout | trim }}"
      when: not reverse_replication | default(false) | bool # skip for reverse replication
  vars:
    publication_name: "{{ pg_publication_name if not reverse_replication | default(false) | bool else pg_reverse_publication_name }}"
    subscription_slot_name: "{{ pg_subscription_slot_name if not reverse_replication | default(false) | bool else pg_reverse_subscription_slot_name }}"
    slot_name: "{{ (subscription_slot_name ~ '_' ~ dbname) | lower | regex_replace('[^a-z0-9_]+', '_') }}"
    publisher_group: "{{ 'target_cluster' if reverse_replication | default(false) | bool else 'source_cluster' }}"
    pg_bindir: "{{ pg_old_bindir if (postgresql_data_dir | regex_replace('/+$', '')) == (pg_old_datadir | regex_replace('/+$', '')) else pg_new_bindir }}"
    psql_command: "{{ pg_bindir }}/psql -h 127.0.0.1 -p {{ postgresql_port }} -U {{ patroni_superuser_username }}"
  environment:
    PGPASSWORD: "{{ patroni_superuser_password }}"
  when:
    - inventory_hostname in (groups.get(publisher_group, []) | default([], true))
    - patroni_cluster_leader | default(false) | bool
    - pg_publication_count | int == 1

# Multiple publications (if pg_publication_count > 1)
- block:
    # Split tables (sorted by DML activity) into groups for publications to evenly distribute tables across slots.
    - name: "Get a list of tables distributed by groups (database: {{ dbname | default('postgres') }})"
      ansible.builtin.shell: |
        {{ psql_command }} -d {{ dbname }} -tAXc "
        do \$$
        declare
          num_groups constant int := {{ pg_publication_count }};
          group_weights bigint[] := array_fill(0, array[num_groups]);
          random_group_index int;
          lowest_weight_index int;
          lowest_weight bigint;
          table_rec record;
        begin
          create temp table tables_groups_tmp (
            group_id int,
            table_name text,
            weight bigint,
            total_weight bigint
          );

          for table_rec in
            select
              format('\\\"%I\\\".\\\"%I\\\"', schemaname, relname) as table_name,
              n_tup_ins + n_tup_upd + n_tup_del as weight
            from pg_stat_user_tables
            where relname <> 'tables_groups_tmp'
              and not exists (
                select 1
                from pg_class
                where oid = pg_stat_user_tables.relid
                  and (relkind = 'p' or relid in (select inhparent from pg_inherits))
              )  -- Exclude parent tables for both declarative and inheritance-based partitioning
            order by weight desc
          loop
            -- for tables with a weight > 0, we find the group with the lowest total weight
            if table_rec.weight > 0 then
              lowest_weight_index := 1;
              lowest_weight := group_weights[1];
              for i in 2..num_groups loop
                if group_weights[i] < lowest_weight then
                  lowest_weight_index := i;
                  lowest_weight := group_weights[i];
                end if;
              end loop;
            -- for tables with a weight = 0, randomly select a group
            else
              random_group_index := (trunc(random() * num_groups) + 1)::int;
              lowest_weight_index := random_group_index;
            end if;

            group_weights[lowest_weight_index] := group_weights[lowest_weight_index] + table_rec.weight;

            insert into tables_groups_tmp (group_id, table_name, weight, total_weight)
            values (lowest_weight_index, table_rec.table_name, table_rec.weight, group_weights[lowest_weight_index]);
          end loop;
        end \$$;

        -- get lists of tables separated by groups
        select
          string_agg(table_name, ',') as tables
        from tables_groups_tmp
        group by group_id
        order by group_id;"
      args:
        executable: /bin/bash
      register: tables_groups

    # Monitor the locks and terminate the backend blocking the 'create publication' query (for more than 10 seconds)
    - name: "Start pg_terminator script: Monitor locks and terminate the 'create publication' blockers"
      ansible.builtin.shell: |
        echo $$ > /tmp/pg_terminator.pid
        for i in {1..360}; do
          {{ psql_command }} -d postgres -tAXc "
          with blocker_pids(pid) as (
            select unnest(pg_blocking_pids(pid))
            from pg_stat_activity
            where
              query ilike '% create publication %'
              and wait_event_type = 'Lock'
          )
          select
            now(),
            pg_terminate_backend(pid),
            pid,
            clock_timestamp() - xact_start as xact_lasted,
            query
          from pg_stat_activity
          where
            pid in (select pid from blocker_pids)
            and xact_start < clock_timestamp() - interval '10s';" >> /tmp/pg_terminator.log
          sleep 10
        done
      args:
        executable: /bin/bash
      async: 3600  # run the command asynchronously, max exec time: 1 hour
      poll: 0

    # Create multiple publications (for each table group)
    # Note: ulimit - will increase stack size and ARG_MAX to prevent error 'Argument list too long'
    - name: "Create publications for logical replication (database: {{ dbname | default('postgres') }})"
      ansible.builtin.shell: >-
        ulimit -S -s {{ create_publication_stack_size | default(32768) }};
        {{ psql_command }} -d {{ dbname }} -tAXc "
        drop publication if exists {{ publication_name }}_{{ '%02d' % (idx + 1) }};
        create publication {{ publication_name }}_{{ '%02d' % (idx + 1) }} for table {{ item }};"
      args:
        executable: /bin/bash
      loop: "{{ tables_groups.stdout_lines | reject('equalto', 'DO') | list }}"
      loop_control:
        index_var: idx
        label: "{{ publication_name }}_{{ '%02d' % (idx + 1) }}"

    # Create multiple slots (for each publication/subscription)
    - name: "Create slots for logical replication (database: {{ dbname | default('postgres') }})"
      ansible.builtin.command: >-
        {{ psql_command }} -d {{ dbname }} -tAXc "
        select pg_drop_replication_slot('{{ slot_name }}_{{ '%02d' % (idx + 1) }}')
        from pg_replication_slots where slot_name = '{{ slot_name }}_{{ '%02d' % (idx + 1) }}';
        select lsn from pg_create_logical_replication_slot('{{ slot_name }}_{{ '%02d' % (idx + 1) }}', 'pgoutput');"
      register: multiple_pg_slot_lsn
      loop: "{{ range(0, pg_publication_count | int) | list }}"
      loop_control:
        index_var: idx
        label: "{{ slot_name }}_{{ '%02d' % (idx + 1) }}"

    - name: "Stop pg_terminator script"
      ansible.builtin.shell: |
        pid=$(cat /tmp/pg_terminator.pid)
        ps -p $pid > /dev/null 2>&1 && kill -9 $pid
      args:
        executable: /bin/bash
      ignore_errors: true

    - name: "Set variable: target_lsn"
      ansible.builtin.set_fact:
        target_lsn: "{{ multiple_pg_slot_lsn['results'][-1]['stdout'] | trim }}"
      when: not reverse_replication | default(false) | bool # skip for reverse replication
  vars:
    publication_name: "{{ pg_publication_name if not reverse_replication | default(false) | bool else pg_reverse_publication_name }}"
    subscription_slot_name: "{{ pg_subscription_slot_name if not reverse_replication | default(false) | bool else pg_reverse_subscription_slot_name }}"
    slot_name: "{{ (subscription_slot_name ~ '_' ~ dbname) | lower | regex_replace('[^a-z0-9_]+', '_') }}"
    publisher_group: "{{ 'target_cluster' if reverse_replication | default(false) | bool else 'source_cluster' }}"
    pg_bindir: "{{ pg_old_bindir if (postgresql_data_dir | regex_replace('/+$', '')) == (pg_old_datadir | regex_replace('/+$', '')) else pg_new_bindir }}"
    psql_command: "{{ pg_bindir }}/psql -h 127.0.0.1 -p {{ postgresql_port }} -U {{ patroni_superuser_username }}"
  environment:
    PGPASSWORD: "{{ patroni_superuser_password }}"
  when:
    - inventory_hostname in (groups.get(publisher_group, []) | default([], true))
    - patroni_cluster_leader | default(false) | bool
    - pg_publication_count | int > 1
