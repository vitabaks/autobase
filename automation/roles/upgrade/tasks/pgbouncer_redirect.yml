---
# Prepare PgBouncer config to redirect traffic to the target cluster (blue-green deployment method)

- name: "Pre-Check error. Fail if replica counts mismatch between source and target clusters"
  ansible.builtin.fail:
    msg: >-
      Replica count mismatch:
      source secondary={{ (groups.get('source_secondary', []) | length) }},
      target secondary={{ (groups.get('secondary', []) | length) }}
  when:
    - inventory_hostname in groups.get('source_primary', [])
    - (groups.get('secondary', []) | length) != (groups.get('source_secondary', []) | length)

- name: Prepare PgBouncer configuration to redirect primary traffic
  ansible.builtin.replace:
    path: "{{ pgbouncer_conf_dir }}/pgbouncer.ini"
    regexp: '(?m)^(\s*[^#;\n]*\bhost=)[^\s]+'
    replace: '\g<1>{{ target_primary_host_addr }}'
  vars:
    target_primary_host: "{{ (groups.get('primary', []) | first) | default('', true) }}"
    target_primary_host_addr: >-
      {{
        hostvars[target_primary_host].patroni_bind_address
        | default(hostvars[target_primary_host].bind_address, true)
        | default(hostvars[target_primary_host].inventory_hostname, true)
      }}
  when: inventory_hostname in groups.get('source_primary', [])

- name: Prepare PgBouncer configuration to redirect replica traffic
  ansible.builtin.replace:
    path: "{{ pgbouncer_conf_dir }}/pgbouncer.ini"
    regexp: '(?m)^(\s*[^#;\n]*\bhost=)[^\s]+'
    replace: '\g<1>{{ target_secondary_host_addr }}'
  vars:
    source_secondaries: "{{ groups.get('source_secondary', []) | sort }}"
    target_secondaries: "{{ groups.get('secondary', []) | sort }}"
    source_idx: "{{ source_secondaries.index(inventory_hostname) }}"
    target_secondary_host: "{{ target_secondaries[source_idx] }}"
    target_secondary_host_addr: >-
      {{
        hostvars[target_secondary_host].patroni_bind_address
        | default(hostvars[target_secondary_host].bind_address, true)
        | default(hostvars[target_secondary_host].inventory_hostname, true)
      }}
  when: inventory_hostname in groups.get('source_secondary', [])

# if self-signed certificates are used (tls_cert_generate = true)
# Target cluster uses a different CA, so PgBouncer on source may fail to verify TLS when connecting to Postgres on target
# This prevents: "could not accept SSL connection: certificate verify failed"
- name: Temporarily disable TLS from PgBouncer to Postgres during redirect
  ansible.builtin.lineinfile:
    path: "{{ pgbouncer_conf_dir }}/pgbouncer.ini"
    regexp: '^\s*server_tls_sslmode\s*='
    line: "server_tls_sslmode = disable"
  when:
    - tls_cert_generate | default(false) | bool
    - inventory_hostname in groups.get('source_cluster', [])

# During blue-green traffic redirection PgBouncer instances will start connecting to the target cluster (old -> new).
# Those PgBouncer-to-Postgres connections come from different node IPs than in the original topology,
# so PostgreSQL must temporarily allow them in pg_hba.conf.
#
# We prepend rules at BOF to ensure they take precedence over existing stricter entries and avoid failures like:
# "no pg_hba.conf entry ..." and "password required" when PgBouncer reconnects during switchover.
# The first rule allows the PgBouncer auth user to connect without password (trust) to keep auth_query working,
# the second rule allows normal clients with the configured password encryption method.
- name: Add temporary hba rule on target for traffic redirection
  ansible.builtin.blockinfile:
    path: "{{ pg_new_confdir }}/pg_hba.conf"
    marker: "# {mark} ANSIBLE: TEMPORARY RULE for traffic redirection"
    insertbefore: BOF
    block: |
      {% for h in groups['source_cluster'] %}
      {% set addr = (
          hostvars[h].patroni_bind_address
          | default(hostvars[h].bind_address, true)
          | default(hostvars[h].inventory_hostname, true)
        )
      %}
      host all {{ pgbouncer_auth_username }} {{ addr }}/32 trust
      host all all {{ addr }}/32 {{ postgresql_password_encryption_algorithm }}
      {% endfor %}
  when: inventory_hostname in groups['target_cluster']

- name: Update the PostgreSQL configuration on target to apply pg_hba.conf changes
  ansible.builtin.command: "{{ psql_command }} -tAXc 'select pg_reload_conf()'"
  vars:
    psql_command: "{{ pg_new_bindir }}/psql -h 127.0.0.1 -p {{ postgresql_port }} -U {{ patroni_superuser_username }} -d postgres"
  environment:
    PGPASSWORD: "{{ patroni_superuser_password }}"
  when: inventory_hostname in groups['target_cluster']

- name: Test access from the source to the target database
  ansible.builtin.command: >-
    {{ pg_old_bindir }}/psql -h {{ target_primary_host_addr }} -p {{ postgresql_port }}
    -U {{ patroni_superuser_username }} -d {{ dbname }} -tAXc 'select 1'
  changed_when: false
  loop: "{{ source_databases }}"
  loop_control:
    loop_var: dbname
    label: "host={{ target_primary_host_addr }} dbname={{ dbname }}"
  vars:
    target_primary_host: "{{ (groups['primary'] | first) | default('', true) }}"
    target_primary_host_addr: >-
      {{
        hostvars[target_primary_host].patroni_bind_address
        | default(hostvars[target_primary_host].bind_address, true)
        | default(hostvars[target_primary_host].inventory_hostname, true)
      }}
  when: inventory_hostname in groups['source_primary']
